#include <memory>
#include <string>
#include <vector>
#include <chrono>
#include <iostream>

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "std_msgs/msg/empty.hpp"
#include "ros2_kdl_package/action/execute_trajectory.hpp"

using namespace std::chrono_literals;

class PickPlaceClient : public rclcpp::Node {
public:
    using ExecuteTrajectory = ros2_kdl_package::action::ExecuteTrajectory;
    using GoalHandle = rclcpp_action::ClientGoalHandle<ExecuteTrajectory>;

    enum class State { SEARCHING, CANCELLING, DESCENDING, ATTACHING, RETURNING, FINISHED };

    PickPlaceClient() : Node("pick_place_client"), current_state_(State::SEARCHING) {
        
        action_client_ = rclcpp_action::create_client<ExecuteTrajectory>(this, "/iiwa/ExecuteTrajectory");

        aruco_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/aruco_single/pose", 10, std::bind(&PickPlaceClient::aruco_callback, this, std::placeholders::_1));

        attach_pub_ = this->create_publisher<std_msgs::msg::Empty>("/gripper/attach", 10);
        detach_pub_ = this->create_publisher<std_msgs::msg::Empty>("/gripper/detach", 10);

        RCLCPP_INFO(this->get_logger(), "--- COORDINATORE AVVIATO ---");
        timer_ = this->create_wall_timer(1s, std::bind(&PickPlaceClient::start_search_motion, this));
    }

private:
    void start_search_motion() {
        timer_->cancel();
        RCLCPP_INFO(this->get_logger(), "Avvio movimento di ricerca...");
        
        auto goal_msg = ExecuteTrajectory::Goal();
        // POSA MIGLIORATA: Guarda bene verso il basso (forma a L)
        // Joint 4 a -1.57 (90 gradi) e Joint 6 a 1.57 orientano la camera giù
        goal_msg.joints_target = {0.0, 0.0, 0.0, 1.57, 0.0, -0.9, 0.0}; 
        
        send_goal(goal_msg);
    }

    void aruco_callback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
        if (current_state_ == State::SEARCHING) {
            RCLCPP_WARN(this->get_logger(), "TAG TROVATO! Freno il robot...");
            target_pose_ = msg->pose;
            current_state_ = State::CANCELLING;
            action_client_->async_cancel_all_goals();
        }
    }

    void result_callback(const GoalHandle::WrappedResult & result) {
        
        // CASO A: Movimento Cancellato -> Scendiamo
        if (result.code == rclcpp_action::ResultCode::CANCELED) {
            if (current_state_ == State::CANCELLING) {
                RCLCPP_INFO(this->get_logger(), "Stop confermato. Scendo sul target.");
                start_descent();
            }
            return;
        }

        // CASO B: Movimento Completato (SUCCEEDED)
        if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
            
            // --- FIX FONDAMENTALE ---
            // Se ha finito il movimento MA noi avevamo già deciso di cancellare (perché visto il tag)
            // allora procediamo come se fosse stato cancellato!
            if (current_state_ == State::CANCELLING) {
                RCLCPP_WARN(this->get_logger(), "Movimento finito prima del cancel, ma TAG visto. Scendo comunque.");
                start_descent();
                return;
            }
            // ------------------------

            if (current_state_ == State::DESCENDING) {
                RCLCPP_INFO(this->get_logger(), "Siamo sul pacco. ATTACH.");
                attach_pub_->publish(std_msgs::msg::Empty());
                rclcpp::sleep_for(2s); 
                
                current_state_ = State::RETURNING;
                RCLCPP_INFO(this->get_logger(), "Pacco preso. Vado al tavolo.");
                send_table_goal();
            }
            else if (current_state_ == State::RETURNING) {
                RCLCPP_INFO(this->get_logger(), "Sul tavolo. DETACH.");
                detach_pub_->publish(std_msgs::msg::Empty());
                current_state_ = State::FINISHED;
                RCLCPP_INFO(this->get_logger(), "--- MISSIONE COMPLETATA ---");
            }
        }
    }

    // Helper per avviare la discesa (per non ripetere codice)
    void start_descent() {
        current_state_ = State::DESCENDING;
        auto goal_msg = ExecuteTrajectory::Goal();
        goal_msg.pose = target_pose_;
        // 5mm di offset
        goal_msg.pose.position.z += 0.005; 
        send_goal(goal_msg);
    }

    void send_goal(ExecuteTrajectory::Goal goal_msg) {
        if (!action_client_->wait_for_action_server(5s)) return;
        auto send_goal_options = rclcpp_action::Client<ExecuteTrajectory>::SendGoalOptions();
        send_goal_options.result_callback = std::bind(&PickPlaceClient::result_callback, this, std::placeholders::_1);
        action_client_->async_send_goal(goal_msg, send_goal_options);
    }

    void send_table_goal() {
        auto goal_msg = ExecuteTrajectory::Goal();
        goal_msg.joints_target = {0.2, 0.9, 0.0, -1.3, 0.0, 0.7, 0.0};
        send_goal(goal_msg);
    }

    State current_state_;
    geometry_msgs::msg::Pose target_pose_;
    rclcpp_action::Client<ExecuteTrajectory>::SharedPtr action_client_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr aruco_sub_;
    rclcpp::Publisher<std_msgs::msg::Empty>::SharedPtr attach_pub_;
    rclcpp::Publisher<std_msgs::msg::Empty>::SharedPtr detach_pub_;
    rclcpp::TimerBase::SharedPtr timer_;
};

int main(int argc, char ** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<PickPlaceClient>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
